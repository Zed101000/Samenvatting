<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Decorator - PlayerMMO Documentation</title>
    
    <style>
        @page {
            size: A4;
            margin: 2cm;
        }
        
        body {
            font-family: 'Segoe UI', Arial, sans-serif;
            line-height: 1.6;
            color: #333;
            max-width: 800px;
            margin: 0 auto;
        }
        
        h1 {
            color: #2c3e50;
            font-size: 24px;
            border-bottom: 3px solid #3498db;
            padding-bottom: 10px;
            margin-bottom: 20px;
        }
        
        h2 {
            color: #34495e;
            font-size: 20px;
            margin-top: 30px;
            margin-bottom: 15px;
        }
        
        h3 {
            color: #2c3e50;
            font-size: 16px;
            margin-top: 25px;
            margin-bottom: 10px;
        }
        
        h4 {
            color: #34495e;
            font-size: 14px;
            margin-top: 20px;
            margin-bottom: 8px;
        }
        
        p {
            margin-bottom: 12px;
            text-align: justify;
        }
        
        code {
            background-color: #f1f3f4;
            padding: 2px 4px;
            border-radius: 3px;
            font-family: 'Consolas', 'Monaco', monospace;
            font-size: 90%;
        }
        
        pre {
            background-color: #f8f9fa;
            border: 1px solid #e9ecef;
            border-radius: 4px;
            padding: 15px;
            overflow-x: auto;
            margin: 15px 0;
        }
        
        pre code {
            background: none;
            padding: 0;
            font-family: 'Consolas', 'Monaco', monospace;
            font-size: 12px;
        }
        
        ul, ol {
            margin-bottom: 15px;
            padding-left: 25px;
        }
        
        li {
            margin-bottom: 5px;
        }
        
        a {
            color: #3498db;
            text-decoration: none;
        }
        
        a:hover {
            text-decoration: underline;
        }
        
        img {
            max-width: 100%;
            height: auto;
            margin: 15px 0;
            border: 1px solid #ddd;
            border-radius: 4px;
        }
        
        table {
            border-collapse: collapse;
            width: 100%;
            margin: 15px 0;
        }
        
        th, td {
            border: 1px solid #ddd;
            padding: 8px;
            text-align: left;
        }
        
        th {
            background-color: #f2f2f2;
            font-weight: bold;
        }
        
        blockquote {
            border-left: 4px solid #3498db;
            margin: 15px 0;
            padding-left: 15px;
            font-style: italic;
            background-color: #f8f9fa;
            padding: 15px;
        }
        
        .document-header {
            text-align: center;
            margin-bottom: 40px;
            padding: 20px;
            background-color: #f8f9fa;
            border-radius: 8px;
        }
        
        .document-footer {
            margin-top: 40px;
            padding-top: 20px;
            border-top: 1px solid #ddd;
            text-align: center;
            font-size: 12px;
            color: #666;
        }
        
        .toc {
            background-color: #f8f9fa;
            padding: 20px;
            border-radius: 6px;
            margin-bottom: 30px;
        }
        
        .page-break {
            page-break-before: always;
        }
    </style>
    
</head>
<body>
    <div class="document-header">
        <h1>PlayerMMO Design Patterns</h1>
        <h2>Decorator</h2>
        <p><strong>Generated:</strong> September 05, 2025 at 02:37:33</p>
    </div>
    
    <div class="content">
        <h1>Decorator Pattern Summary</h1>

<h2>üìñ Overview</h2>
<p>The Decorator pattern allows behavior to be added to objects dynamically without altering their structure by placing these objects inside special wrapper objects that contain the behaviors.</p>

<h2>üéØ Purpose</h2>
<ul>
<li>Add responsibilities to objects dynamically</li>
<li>Provide flexible alternative to subclassing for extending functionality</li>
<li>Wrap objects with additional behavior layers</li>
<li>Compose behavior by stacking decorators</li>
</ul>

<h2>üìã Generic Implementation Guidelines</h2>

<h3>Standard Structure</h3>
<p>1. <strong>Component Interface</strong></p>
<pre><code>
   interface IComponent {
       string Operation();
   }
</code></pre>

<p>2. <strong>Concrete Component</strong></p>
<pre><code>
   class ConcreteComponent : IComponent {
       public string Operation() {
           return &quot;ConcreteComponent&quot;;
       }
   }
</code></pre>

<p>3. <strong>Base Decorator</strong></p>
<pre><code>
   abstract class BaseDecorator : IComponent {
       protected IComponent component;
       
       public BaseDecorator(IComponent component) {
           this.component = component;
       }
       
       public virtual string Operation() {
           return component.Operation();
       }
   }
</code></pre>

<p>4. <strong>Concrete Decorators</strong></p>
<pre><code>
   class ConcreteDecoratorA : BaseDecorator {
       public ConcreteDecoratorA(IComponent component) : base(component) { }
       
       public override string Operation() {
           return $&quot;DecoratorA({base.Operation()})&quot;;
       }
   }
   
   class ConcreteDecoratorB : BaseDecorator {
       public ConcreteDecoratorB(IComponent component) : base(component) { }
       
       public override string Operation() {
           return $&quot;DecoratorB({base.Operation()})&quot;;
       }
       
       // Additional method specific to this decorator
       public string ExtraOperation() {
           return &quot;Extra functionality from DecoratorB&quot;;
       }
   }
</code></pre>

<p>5. <strong>Client Usage</strong></p>
<pre><code>
   // Base component
   IComponent component = new ConcreteComponent();
   Console.WriteLine(component.Operation()); // &quot;ConcreteComponent&quot;
   
   // Add decorators
   component = new ConcreteDecoratorA(component);
   Console.WriteLine(component.Operation()); // &quot;DecoratorA(ConcreteComponent)&quot;
   
   component = new ConcreteDecoratorB(component);
   Console.WriteLine(component.Operation()); // &quot;DecoratorB(DecoratorA(ConcreteComponent))&quot;
</code></pre>

<h3>When to Use</h3>
<ul>
<li>Want to add responsibilities to objects without subclassing</li>
<li>Need to add functionality that can be withdrawn</li>
<li>Extension by subclassing is impractical or impossible</li>
<li>Want to compose behavior dynamically</li>
</ul>

<h2>üèóÔ∏è Implementation in PlayerMMO</h2>

<h3>Key Components</h3>
<ul>
<li><strong>IWeapon</strong>: Base weapon interface for all weapons and decorators</li>
<li><strong>BaseWeapon</strong>: Simple weapon implementation</li>
<li><strong>WeaponDecorator</strong>: Abstract base decorator for weapon enhancements</li>
<li><strong>Concrete Decorators</strong>: Fire enhancement, ice enhancement, critical hit enhancement</li>
<li><strong>Stacking system</strong>: Multiple enhancements can be applied to same weapon</li>
</ul>

<h3>Code Structure</h3>
<pre><code>
PlayerMMO/Decorator/
‚îú‚îÄ‚îÄ ItemsDecorator/
‚îÇ   ‚îú‚îÄ‚îÄ IWeapon.cs
‚îÇ   ‚îú‚îÄ‚îÄ BaseWeapon.cs
‚îÇ   ‚îú‚îÄ‚îÄ WeaponDecorator.cs
‚îÇ   ‚îú‚îÄ‚îÄ FireEnhancement.cs
‚îÇ   ‚îú‚îÄ‚îÄ IceEnhancement.cs
‚îÇ   ‚îî‚îÄ‚îÄ CriticalHitEnhancement.cs
‚îú‚îÄ‚îÄ Program.cs
‚îî‚îÄ‚îÄ Decorator.puml
</code></pre>

<h2>üéÆ Game Integration</h2>
<ul>
<li><strong>BaseGame Classes Used</strong>: IPlayer, IMonster</li>
<li><strong>Game Context</strong>: Weapon enhancement system for dynamic item upgrades</li>
<li><strong>Demo Features</strong>: Stackable enhancements, damage calculations, special effects</li>
</ul>

<h3>Actual Implementation Mapping</h3>
<p>| Generic Component | PlayerMMO Implementation | Purpose |</p>
<p>|------------------|-------------------------|---------|</p>
<p>| IComponent | IWeapon | Base weapon interface |</p>
<p>| ConcreteComponent | BaseWeapon | Simple weapon implementation |</p>
<p>| BaseDecorator | WeaponDecorator | Abstract weapon enhancement |</p>
<p>| ConcreteDecoratorA | FireEnhancement | Fire damage enhancement |</p>
<p>| ConcreteDecoratorB | IceEnhancement | Ice effect enhancement |</p>
<p>| | CriticalHitEnhancement | Critical hit enhancement |</p>
<p>| Operation() | Attack(), GetDamage() | Weapon operations |</p>
<p>| Client | Program.cs demo | Game using enhanced weapons |</p>

<h3>Real Usage Example</h3>
<pre><code>
// Start with basic weapon
IWeapon basicSword = new BaseWeapon(&quot;Iron Sword&quot;, 20);
Console.WriteLine($&quot;{basicSword.GetName()}: {basicSword.GetDamage()} damage&quot;);
// Output: &quot;Iron Sword: 20 damage&quot;

// Add fire enhancement
IWeapon fireSword = new FireEnhancement(basicSword);
Console.WriteLine($&quot;{fireSword.GetName()}: {fireSword.GetDamage()} damage&quot;);
// Output: &quot;Iron Sword with Fire Enhancement: 25 damage&quot;

// Stack ice enhancement on top of fire
IWeapon magicalSword = new IceEnhancement(fireSword);
Console.WriteLine($&quot;{magicalSword.GetName()}: {magicalSword.GetDamage()} damage&quot;);
// Output: &quot;Iron Sword with Fire Enhancement with Ice Enhancement: 32 damage&quot;

// Add critical hit enhancement
IWeapon ultimateSword = new CriticalHitEnhancement(magicalSword);
Console.WriteLine($&quot;{ultimateSword.GetName()}: {ultimateSword.GetDamage()} damage&quot;);
// Output: &quot;Iron Sword with Fire Enhancement with Ice Enhancement with Critical Hit: 42 damage&quot;

// Combat demonstration
var player = new BasePlayer(&quot;Hero&quot;);
var monster = new BaseMonster(&quot;Dragon&quot;, 5);

Console.WriteLine(&quot;\n=== Combat with Enhanced Weapon ===&quot;);
int damage = ultimateSword.Attack();
monster.Health -= damage;

Console.WriteLine($&quot;Hero attacks Dragon with {ultimateSword.GetName()}&quot;);
Console.WriteLine($&quot;Damage dealt: {damage}&quot;);
Console.WriteLine($&quot;Dragon health remaining: {monster.Health}&quot;);

// Dynamic enhancement during gameplay
Console.WriteLine(&quot;\n=== Dynamic Enhancement ===&quot;);
IWeapon playerWeapon = new BaseWeapon(&quot;Steel Dagger&quot;, 15);

// Player finds fire gem
Console.WriteLine(&quot;Player finds Fire Gem!&quot;);
playerWeapon = new FireEnhancement(playerWeapon);
Console.WriteLine($&quot;Weapon upgraded: {playerWeapon.GetName()}&quot;);

// Player completes ice dungeon
Console.WriteLine(&quot;Player completes Ice Dungeon!&quot;);
playerWeapon = new IceEnhancement(playerWeapon);
Console.WriteLine($&quot;Weapon upgraded: {playerWeapon.GetName()}&quot;);

// Boss drops critical enhancement
Console.WriteLine(&quot;Boss drops Critical Enhancement!&quot;);
playerWeapon = new CriticalHitEnhancement(playerWeapon);
Console.WriteLine($&quot;Final weapon: {playerWeapon.GetName()}&quot;);
Console.WriteLine($&quot;Final damage: {playerWeapon.GetDamage()}&quot;);

// Benefits demonstrated:
// - Weapons can be enhanced dynamically during gameplay
// - Multiple enhancements stack naturally
// - Original weapon behavior is preserved
// - No need to create separate classes for every combination
// - Easy to add/remove enhancements
// - Flexible enhancement system supports any combination

// Collection of enhanced weapons
var weaponShop = new List&lt;IWeapon&gt; {
    new FireEnhancement(new BaseWeapon(&quot;Fire Sword&quot;, 25)),
    new IceEnhancement(new BaseWeapon(&quot;Ice Spear&quot;, 22)),
    new CriticalHitEnhancement(
        new FireEnhancement(
            new BaseWeapon(&quot;Legendary Blade&quot;, 30)
        )
    )
};

foreach (var weapon in weaponShop) {
    Console.WriteLine($&quot;Shop: {weapon.GetName()} - {weapon.GetDamage()} damage&quot;);
}
</code></pre>

<h2>‚ú® Key Benefits</h2>
<ul>
<li><strong>Runtime Composition</strong>: Add functionality at runtime</li>
<li><strong>Single Responsibility</strong>: Each decorator has one enhancement</li>
<li><strong>Flexible Combination</strong>: Stack decorators in any order</li>
<li><strong>Open/Closed Principle</strong>: Open for extension, closed for modification</li>
</ul>

<h2>üîß Advanced Decorator Features</h2>
<pre><code>
// Decorator with conditional behavior
public class ConditionalFireEnhancement : WeaponDecorator {
    private readonly Func&lt;bool&gt; condition;
    
    public ConditionalFireEnhancement(IWeapon weapon, Func&lt;bool&gt; condition) 
        : base(weapon) {
        this.condition = condition;
    }
    
    public override int Attack() {
        int baseDamage = base.Attack();
        
        if (condition()) {
            Console.WriteLine(&quot;üî• Fire enhancement activated!&quot;);
            return baseDamage + 10;
        }
        
        return baseDamage;
    }
}

// Usage: Fire only works in cold environments
var conditionalWeapon = new ConditionalFireEnhancement(
    basicSword, 
    () =&gt; CurrentEnvironment.Temperature &lt; 0
);

// Decorator with state tracking
public class ChargeableEnhancement : WeaponDecorator {
    private int charges;
    private readonly int maxCharges;
    
    public ChargeableEnhancement(IWeapon weapon, int maxCharges) 
        : base(weapon) {
        this.maxCharges = maxCharges;
        this.charges = maxCharges;
    }
    
    public override int Attack() {
        int baseDamage = base.Attack();
        
        if (charges &gt; 0) {
            charges--;
            Console.WriteLine($&quot;‚ö° Lightning strike! ({charges} charges left)&quot;);
            return baseDamage + 15;
        }
        
        return baseDamage;
    }
    
    public void Recharge() {
        charges = maxCharges;
        Console.WriteLine(&quot;üîã Weapon recharged!&quot;);
    }
}

// Decorator with removal capability
public interface IRemovableDecorator {
    IWeapon RemoveDecorator();
}

public class RemovableFireEnhancement : WeaponDecorator, IRemovableDecorator {
    public RemovableFireEnhancement(IWeapon weapon) : base(weapon) { }
    
    public IWeapon RemoveDecorator() {
        return weapon; // Return the wrapped weapon
    }
    
    public override string GetName() {
        return $&quot;{weapon.GetName()} [Removable Fire]&quot;;
    }
}

// Decorator composition helper
public static class WeaponEnhancer {
    public static IWeapon Enhance(IWeapon weapon, params Type[] enhancementTypes) {
        IWeapon enhanced = weapon;
        
        foreach (var type in enhancementTypes) {
            enhanced = (IWeapon)Activator.CreateInstance(type, enhanced);
        }
        
        return enhanced;
    }
}

// Usage
var autoEnhanced = WeaponEnhancer.Enhance(
    basicSword,
    typeof(FireEnhancement),
    typeof(IceEnhancement),
    typeof(CriticalHitEnhancement)
);
</code></pre>

<h2>üîó Related Patterns</h2>
<ul>
<li><strong>Composite</strong>: Both use recursive composition but for different purposes</li>
<li><strong>Adapter</strong>: Both wrap objects but for different reasons</li>
<li><strong>Strategy</strong>: Both provide alternatives but decorator adds behavior</li>
<li><strong>Chain of Responsibility</strong>: Similar structure but different intent</li>
</ul>

<h2>üìä UML Diagrams</h2>

<h3>Generic Pattern Structure</h3>
<div class="image-container"><img src="https://raw.githubusercontent.com/Zed101000/Samenvatting/main/PlayerMMO/Decorator/generic_decorator.png" alt="Generic Decorator UML" style="max-width: 100%; height: auto; border: 1px solid #ddd; border-radius: 8px; margin: 20px 0;"></div>

<h3>PlayerMMO Implementation</h3>
<div class="image-container"><img src="https://raw.githubusercontent.com/Zed101000/Samenvatting/main/PlayerMMO/Decorator/Decorator.png" alt="Decorator UML" style="max-width: 100%; height: auto; border: 1px solid #ddd; border-radius: 8px; margin: 20px 0;"></div>

<p>---</p>
<a href="./index.html">‚Üê Back to Main Pattern Summary</a>

    </div>
    
    <div class="document-footer">
        <p><em>Generated from PlayerMMO Design Patterns Documentation</em></p>
        <p>¬© 2025 PlayerMMO Project</p>
    </div>
</body>
</html>
