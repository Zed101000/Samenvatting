<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Adapter - PlayerMMO Documentation</title>
    
    <style>
        @page {
            size: A4;
            margin: 2cm;
        }
        
        body {
            font-family: 'Segoe UI', Arial, sans-serif;
            line-height: 1.6;
            color: #333;
            max-width: 800px;
            margin: 0 auto;
        }
        
        h1 {
            color: #2c3e50;
            font-size: 24px;
            border-bottom: 3px solid #3498db;
            padding-bottom: 10px;
            margin-bottom: 20px;
        }
        
        h2 {
            color: #34495e;
            font-size: 20px;
            margin-top: 30px;
            margin-bottom: 15px;
        }
        
        h3 {
            color: #2c3e50;
            font-size: 16px;
            margin-top: 25px;
            margin-bottom: 10px;
        }
        
        h4 {
            color: #34495e;
            font-size: 14px;
            margin-top: 20px;
            margin-bottom: 8px;
        }
        
        p {
            margin-bottom: 12px;
            text-align: justify;
        }
        
        code {
            background-color: #f1f3f4;
            padding: 2px 4px;
            border-radius: 3px;
            font-family: 'Consolas', 'Monaco', monospace;
            font-size: 90%;
        }
        
        pre {
            background-color: #f8f9fa;
            border: 1px solid #e9ecef;
            border-radius: 4px;
            padding: 15px;
            overflow-x: auto;
            margin: 15px 0;
        }
        
        pre code {
            background: none;
            padding: 0;
            font-family: 'Consolas', 'Monaco', monospace;
            font-size: 12px;
        }
        
        ul, ol {
            margin-bottom: 15px;
            padding-left: 25px;
        }
        
        li {
            margin-bottom: 5px;
        }
        
        a {
            color: #3498db;
            text-decoration: none;
        }
        
        a:hover {
            text-decoration: underline;
        }
        
        img {
            max-width: 100%;
            height: auto;
            margin: 15px 0;
            border: 1px solid #ddd;
            border-radius: 4px;
        }
        
        table {
            border-collapse: collapse;
            width: 100%;
            margin: 15px 0;
        }
        
        th, td {
            border: 1px solid #ddd;
            padding: 8px;
            text-align: left;
        }
        
        th {
            background-color: #f2f2f2;
            font-weight: bold;
        }
        
        blockquote {
            border-left: 4px solid #3498db;
            margin: 15px 0;
            padding-left: 15px;
            font-style: italic;
            background-color: #f8f9fa;
            padding: 15px;
        }
        
        .document-header {
            text-align: center;
            margin-bottom: 40px;
            padding: 20px;
            background-color: #f8f9fa;
            border-radius: 8px;
        }
        
        .document-footer {
            margin-top: 40px;
            padding-top: 20px;
            border-top: 1px solid #ddd;
            text-align: center;
            font-size: 12px;
            color: #666;
        }
        
        .toc {
            background-color: #f8f9fa;
            padding: 20px;
            border-radius: 6px;
            margin-bottom: 30px;
        }
        
        .page-break {
            page-break-before: always;
        }
    </style>
    
</head>
<body>
    <div class="document-header">
        <h1>PlayerMMO Design Patterns</h1>
        <h2>Adapter</h2>
        <p><strong>Generated:</strong> September 05, 2025 at 02:37:33</p>
    </div>
    
    <div class="content">
        <h1>Adapter Pattern Summary</h1>

<h2>üìñ Overview</h2>
<p>The Adapter pattern allows incompatible interfaces to work together by converting the interface of a class into another interface that clients expect.</p>

<h2>üéØ Purpose</h2>
<ul>
<li>Allow incompatible interfaces to work together</li>
<li>Convert existing class interface to expected interface</li>
<li>Reuse existing code with new systems</li>
<li>Wrap legacy components for modern applications</li>
</ul>

<h2>üìã Generic Implementation Guidelines</h2>

<h3>Standard Structure</h3>
<p>1. <strong>Target Interface</strong></p>
<pre><code>
   interface ITarget {
       string Request();
   }
</code></pre>

<p>2. <strong>Adaptee (Legacy Class)</strong></p>
<pre><code>
   class Adaptee {
       public string SpecificRequest() {
           return &quot;Special behavior from legacy system&quot;;
       }
   }
</code></pre>

<p>3. <strong>Adapter</strong></p>
<pre><code>
   class Adapter : ITarget {
       private readonly Adaptee adaptee;
       
       public Adapter(Adaptee adaptee) {
           this.adaptee = adaptee;
       }
       
       public string Request() {
           // Convert adaptee&#x27;s interface to target interface
           return $&quot;Adapter: {adaptee.SpecificRequest()}&quot;;
       }
   }
</code></pre>

<p>4. <strong>Client Usage</strong></p>
<pre><code>
   // Legacy system
   var adaptee = new Adaptee();
   
   // Adapt legacy system to new interface
   ITarget adapter = new Adapter(adaptee);
   
   // Client uses standard interface
   string result = adapter.Request();
   Console.WriteLine(result); // &quot;Adapter: Special behavior from legacy system&quot;
</code></pre>

<h3>Object vs Class Adapter</h3>
<ul>
<li><strong>Object Adapter</strong>: Uses composition (shown above)</li>
<li><strong>Class Adapter</strong>: Uses inheritance (not always possible in C#)</li>
</ul>

<h3>When to Use</h3>
<ul>
<li>Need to use existing class with incompatible interface</li>
<li>Want to create reusable class that cooperates with unrelated classes</li>
<li>Need to use several existing subclasses, but impractical to adapt by subclassing</li>
<li>Integrating third-party libraries with your application</li>
</ul>

<h2>üèóÔ∏è Implementation in PlayerMMO</h2>

<h3>Key Components</h3>
<ul>
<li><strong>INewWeaponSystem</strong>: Modern weapon interface expected by new game engine</li>
<li><strong>LegacyWeapon</strong>: Old weapon system with different interface</li>
<li><strong>WeaponAdapter</strong>: Converts legacy weapons to new interface</li>
<li><strong>AdvancedWeaponAdapter</strong>: Enhanced adapter with additional features</li>
<li><strong>Game integration</strong>: Seamless use of old and new weapon systems</li>
</ul>

<h3>Code Structure</h3>
<pre><code>
PlayerMMO/Adapter/
‚îú‚îÄ‚îÄ AdapterPattern/
‚îÇ   ‚îú‚îÄ‚îÄ INewWeaponSystem.cs
‚îÇ   ‚îú‚îÄ‚îÄ LegacyWeapon.cs
‚îÇ   ‚îú‚îÄ‚îÄ WeaponAdapter.cs
‚îÇ   ‚îî‚îÄ‚îÄ AdvancedWeaponAdapter.cs
‚îú‚îÄ‚îÄ Program.cs
‚îî‚îÄ‚îÄ Adapter.puml
</code></pre>

<h2>üéÆ Game Integration</h2>
<ul>
<li><strong>BaseGame Classes Used</strong>: IPlayer, IMonster</li>
<li><strong>Game Context</strong>: Weapon system compatibility between old and new game versions</li>
<li><strong>Demo Features</strong>: Legacy weapon integration, damage calculation, enhanced weapon features</li>
</ul>

<h3>Actual Implementation Mapping</h3>
<p>| Generic Component | PlayerMMO Implementation | Purpose |</p>
<p>|------------------|-------------------------|---------|</p>
<p>| ITarget | INewWeaponSystem | Modern weapon interface |</p>
<p>| Adaptee | LegacyWeapon | Old weapon system |</p>
<p>| Adapter | WeaponAdapter | Basic legacy weapon adapter |</p>
<p>| | AdvancedWeaponAdapter | Enhanced adapter with features |</p>
<p>| Client | Program.cs demo | Game using adapted weapons |</p>
<p>| Request() | Attack(), GetDamage() | Weapon operation methods |</p>

<h3>Real Usage Example</h3>
<pre><code>
// Legacy weapon from old game version
var legacyFireSword = new LegacyWeapon(&quot;Fire Sword&quot;, 25, &quot;fire&quot;);

// New game engine expects INewWeaponSystem interface
// Adapt legacy weapon to new interface
INewWeaponSystem adaptedWeapon = new WeaponAdapter(legacyFireSword);

// Now legacy weapon works with new game engine
var player = new BasePlayer(&quot;Hero&quot;);
var monster = new BaseMonster(&quot;Dragon&quot;, 3);

// Use adapted weapon seamlessly
int damage = adaptedWeapon.GetDamage();
string effect = adaptedWeapon.GetSpecialEffect();

Console.WriteLine($&quot;Hero attacks with {adaptedWeapon.GetWeaponName()}&quot;);
Console.WriteLine($&quot;Damage: {damage}, Effect: {effect}&quot;);

// Enhanced adapter with additional features
var enhancedAdapter = new AdvancedWeaponAdapter(legacyFireSword);
enhancedAdapter.AddEnchantment(&quot;Lightning&quot;); // New feature not in legacy

// Attack with enhanced capabilities
monster.Health -= enhancedAdapter.Attack();
if (enhancedAdapter.HasCriticalHit()) {
    Console.WriteLine(&quot;üí• CRITICAL HIT! Double damage!&quot;);
    monster.Health -= enhancedAdapter.GetDamage(); // Additional damage
}

// Benefits demonstrated:
// - Old weapons work in new game engine
// - No need to rewrite legacy weapon data
// - Enhanced features can be added through adapter
// - Consistent interface for all weapons (old and new)

// Multiple legacy weapon types
var legacyIceBow = new LegacyWeapon(&quot;Ice Bow&quot;, 20, &quot;ice&quot;);
var legacyThunderHammer = new LegacyWeapon(&quot;Thunder Hammer&quot;, 35, &quot;lightning&quot;);

// All adapted to same interface
var weapons = new List&lt;INewWeaponSystem&gt; {
    new WeaponAdapter(legacyFireSword),
    new WeaponAdapter(legacyIceBow),
    new AdvancedWeaponAdapter(legacyThunderHammer)
};

// Uniform handling of all weapons
foreach (var weapon in weapons) {
    Console.WriteLine($&quot;Weapon: {weapon.GetWeaponName()}, &quot; +
                     $&quot;Damage: {weapon.GetDamage()}, &quot; +
                     $&quot;Effect: {weapon.GetSpecialEffect()}&quot;);
}
</code></pre>

<h2>‚ú® Key Benefits</h2>
<ul>
<li><strong>Legacy Integration</strong>: Use old components with new systems</li>
<li><strong>Interface Standardization</strong>: Uniform interface for different implementations</li>
<li><strong>Code Reuse</strong>: Avoid rewriting existing functionality</li>
<li><strong>Backwards Compatibility</strong>: Support old data formats and systems</li>
</ul>

<h2>üîß Advanced Adapter Features</h2>
<pre><code>
// Two-way adapter (bidirectional)
class BidirectionalWeaponAdapter : INewWeaponSystem, ILegacyWeaponInterface {
    private readonly LegacyWeapon legacyWeapon;
    
    public BidirectionalWeaponAdapter(LegacyWeapon weapon) {
        this.legacyWeapon = weapon;
    }
    
    // Adapt to new interface
    public int GetDamage() =&gt; legacyWeapon.GetPower();
    public string GetWeaponName() =&gt; legacyWeapon.GetName();
    
    // Adapt to legacy interface
    public int GetPower() =&gt; GetDamage();
    public string GetName() =&gt; GetWeaponName();
}

// Class adapter using inheritance (when possible)
class InheritanceWeaponAdapter : LegacyWeapon, INewWeaponSystem {
    public InheritanceWeaponAdapter(string name, int power, string element) 
        : base(name, power, element) { }
    
    public int GetDamage() =&gt; GetPower(); // Inherit from LegacyWeapon
    public string GetWeaponName() =&gt; GetName(); // Inherit from LegacyWeapon
    
    public string GetSpecialEffect() {
        return $&quot;Inherited {GetElement()} effect&quot;;
    }
    
    public int Attack() {
        // Enhanced attack logic while using inherited functionality
        return GetPower() + (GetElement() == &quot;fire&quot; ? 5 : 0);
    }
}

// Adapter with caching and optimization
class CachedWeaponAdapter : INewWeaponSystem {
    private readonly LegacyWeapon legacyWeapon;
    private int? cachedDamage;
    private string cachedEffect;
    
    public int GetDamage() {
        // Cache expensive calculations
        return cachedDamage ??= CalculateEnhancedDamage();
    }
    
    private int CalculateEnhancedDamage() {
        // Complex damage calculation based on legacy weapon
        return legacyWeapon.GetPower() * GetElementMultiplier();
    }
}
</code></pre>

<h2>üîó Related Patterns</h2>
<ul>
<li><strong>Bridge</strong>: Both separate interface from implementation</li>
<li><strong>Decorator</strong>: Both wrap existing objects, but different purposes</li>
<li><strong>Facade</strong>: Provides simplified interface, Adapter provides compatible interface</li>
<li><strong>Proxy</strong>: Both act as intermediaries but for different reasons</li>
</ul>

<h2>üìä UML Diagrams</h2>

<h3>Generic Pattern Structure</h3>
<p>!<a href="../Adapter/generic_adapter.png">Generic Adapter UML</a></p>

<h3>PlayerMMO Implementation</h3>
<p>!<a href="../Adapter/Adapter.png">Adapter UML</a></p>

<p>---</p>
<a href="../Summaries/README.md">‚Üê Back to Main Pattern Summary</a>

    </div>
    
    <div class="document-footer">
        <p><em>Generated from PlayerMMO Design Patterns Documentation</em></p>
        <p>¬© 2025 PlayerMMO Project</p>
    </div>
</body>
</html>
