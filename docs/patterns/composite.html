<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Composite - PlayerMMO Documentation</title>
    
    <style>
        @page {
            size: A4;
            margin: 2cm;
        }
        
        body {
            font-family: 'Segoe UI', Arial, sans-serif;
            line-height: 1.6;
            color: #333;
            max-width: 800px;
            margin: 0 auto;
        }
        
        h1 {
            color: #2c3e50;
            font-size: 24px;
            border-bottom: 3px solid #3498db;
            padding-bottom: 10px;
            margin-bottom: 20px;
        }
        
        h2 {
            color: #34495e;
            font-size: 20px;
            margin-top: 30px;
            margin-bottom: 15px;
        }
        
        h3 {
            color: #2c3e50;
            font-size: 16px;
            margin-top: 25px;
            margin-bottom: 10px;
        }
        
        h4 {
            color: #34495e;
            font-size: 14px;
            margin-top: 20px;
            margin-bottom: 8px;
        }
        
        p {
            margin-bottom: 12px;
            text-align: justify;
        }
        
        code {
            background-color: #f1f3f4;
            padding: 2px 4px;
            border-radius: 3px;
            font-family: 'Consolas', 'Monaco', monospace;
            font-size: 90%;
        }
        
        pre {
            background-color: #f8f9fa;
            border: 1px solid #e9ecef;
            border-radius: 4px;
            padding: 15px;
            overflow-x: auto;
            margin: 15px 0;
        }
        
        pre code {
            background: none;
            padding: 0;
            font-family: 'Consolas', 'Monaco', monospace;
            font-size: 12px;
        }
        
        ul, ol {
            margin-bottom: 15px;
            padding-left: 25px;
        }
        
        li {
            margin-bottom: 5px;
        }
        
        a {
            color: #3498db;
            text-decoration: none;
        }
        
        a:hover {
            text-decoration: underline;
        }
        
        img {
            max-width: 100%;
            height: auto;
            margin: 15px 0;
            border: 1px solid #ddd;
            border-radius: 4px;
        }
        
        table {
            border-collapse: collapse;
            width: 100%;
            margin: 15px 0;
        }
        
        th, td {
            border: 1px solid #ddd;
            padding: 8px;
            text-align: left;
        }
        
        th {
            background-color: #f2f2f2;
            font-weight: bold;
        }
        
        blockquote {
            border-left: 4px solid #3498db;
            margin: 15px 0;
            padding-left: 15px;
            font-style: italic;
            background-color: #f8f9fa;
            padding: 15px;
        }
        
        .document-header {
            text-align: center;
            margin-bottom: 40px;
            padding: 20px;
            background-color: #f8f9fa;
            border-radius: 8px;
        }
        
        .document-footer {
            margin-top: 40px;
            padding-top: 20px;
            border-top: 1px solid #ddd;
            text-align: center;
            font-size: 12px;
            color: #666;
        }
        
        .toc {
            background-color: #f8f9fa;
            padding: 20px;
            border-radius: 6px;
            margin-bottom: 30px;
        }
        
        .page-break {
            page-break-before: always;
        }
    </style>
    
</head>
<body>
    <div class="document-header">
        <h1>PlayerMMO Design Patterns</h1>
        <h2>Composite</h2>
        <p><strong>Generated:</strong> September 05, 2025 at 02:37:33</p>
    </div>
    
    <div class="content">
        <h1>Composite Pattern Summary</h1>

<h2>üìñ Overview</h2>
<p>The Composite pattern composes objects into tree structures to represent part-whole hierarchies, allowing clients to treat individual objects and compositions uniformly.</p>

<h2>üéØ Purpose</h2>
<ul>
<li>Represent part-whole hierarchies of objects</li>
<li>Treat individual objects and compositions uniformly</li>
<li>Build complex structures from simple components</li>
<li>Simplify client code by using uniform interface</li>
</ul>

<h2>üìã Generic Implementation Guidelines</h2>

<h3>Standard Structure</h3>
<p>1. <strong>Component Interface</strong></p>
<pre><code>
   abstract class Component {
       protected string name;
       
       public Component(string name) {
           this.name = name;
       }
       
       public abstract void Operation();
       
       // Optional: methods for managing children
       public virtual void Add(Component component) {
           throw new NotSupportedException();
       }
       
       public virtual void Remove(Component component) {
           throw new NotSupportedException();
       }
       
       public virtual Component GetChild(int index) {
           throw new NotSupportedException();
       }
   }
</code></pre>

<p>2. <strong>Leaf (Simple Component)</strong></p>
<pre><code>
   class Leaf : Component {
       public Leaf(string name) : base(name) { }
       
       public override void Operation() {
           Console.WriteLine($&quot;Leaf {name} operation&quot;);
       }
   }
</code></pre>

<p>3. <strong>Composite (Container Component)</strong></p>
<pre><code>
   class Composite : Component {
       private List&lt;Component&gt; children = new List&lt;Component&gt;();
       
       public Composite(string name) : base(name) { }
       
       public override void Operation() {
           Console.WriteLine($&quot;Composite {name} operation&quot;);
           
           // Delegate to all children
           foreach (var child in children) {
               child.Operation();
           }
       }
       
       public override void Add(Component component) {
           children.Add(component);
       }
       
       public override void Remove(Component component) {
           children.Remove(component);
       }
       
       public override Component GetChild(int index) {
           return children[index];
       }
   }
</code></pre>

<p>4. <strong>Client Usage</strong></p>
<pre><code>
   // Create leaf components
   var leaf1 = new Leaf(&quot;Leaf 1&quot;);
   var leaf2 = new Leaf(&quot;Leaf 2&quot;);
   var leaf3 = new Leaf(&quot;Leaf 3&quot;);
   
   // Create composite components
   var composite1 = new Composite(&quot;Composite 1&quot;);
   var composite2 = new Composite(&quot;Composite 2&quot;);
   
   // Build hierarchy
   composite1.Add(leaf1);
   composite1.Add(leaf2);
   composite2.Add(leaf3);
   composite2.Add(composite1); // Nested composite
   
   // Treat uniformly
   composite2.Operation(); // Operates on entire tree
</code></pre>

<h3>When to Use</h3>
<ul>
<li>Want to represent part-whole hierarchies</li>
<li>Want clients to ignore differences between compositions and individual objects</li>
<li>Want to build complex structures from simpler ones</li>
<li>Need recursive composition with arbitrary depth</li>
</ul>

<h2>üèóÔ∏è Implementation in PlayerMMO</h2>

<h3>Key Components</h3>
<ul>
<li><strong>GameComponent</strong>: Abstract base for all game elements</li>
<li><strong>SimpleGameItem</strong>: Leaf components (individual items, units)</li>
<li><strong>GameContainer</strong>: Composite components (groups, inventories, armies)</li>
<li><strong>Hierarchical structure</strong>: Items in containers, units in squads, squads in armies</li>
</ul>

<h3>Code Structure</h3>
<pre><code>
PlayerMMO/Composite/
‚îú‚îÄ‚îÄ CompositePattern/
‚îÇ   ‚îú‚îÄ‚îÄ GameComponent.cs
‚îÇ   ‚îú‚îÄ‚îÄ SimpleGameItem.cs
‚îÇ   ‚îú‚îÄ‚îÄ GameContainer.cs
‚îÇ   ‚îî‚îÄ‚îÄ CompositeOperations.cs
‚îú‚îÄ‚îÄ Program.cs
‚îî‚îÄ‚îÄ composite.puml
</code></pre>

<h2>üéÆ Game Integration</h2>
<ul>
<li><strong>BaseGame Classes Used</strong>: IPlayer, IMonster</li>
<li><strong>Game Context</strong>: Hierarchical game structures like inventories, party systems, world maps</li>
<li><strong>Demo Features</strong>: Nested containers, inventory management, group operations</li>
</ul>

<h3>Actual Implementation Mapping</h3>
<p>| Generic Component | PlayerMMO Implementation | Purpose |</p>
<p>|------------------|-------------------------|---------|</p>
<p>| Component | GameComponent | Base for all game elements |</p>
<p>| Leaf | SimpleGameItem | Individual items/units |</p>
<p>| Composite | GameContainer | Groups and collections |</p>
<p>| Operation() | Display(), CalculateValue() | Game element operations |</p>
<p>| Add/Remove | AddItem(), RemoveItem() | Container management |</p>
<p>| Client | Program.cs demo | Game using composite structures |</p>

<h3>Real Usage Example</h3>
<pre><code>
// Create individual game items (leaves)
var sword = new SimpleGameItem(&quot;Magic Sword&quot;, 100);
var shield = new SimpleGameItem(&quot;Dragon Shield&quot;, 75);
var potion = new SimpleGameItem(&quot;Health Potion&quot;, 25);
var gem = new SimpleGameItem(&quot;Ruby Gem&quot;, 200);

// Create containers (composites)
var weapons = new GameContainer(&quot;Weapons&quot;);
var armor = new GameContainer(&quot;Armor&quot;);
var consumables = new GameContainer(&quot;Consumables&quot;);
var inventory = new GameContainer(&quot;Player Inventory&quot;);

// Build hierarchical structure
weapons.AddItem(sword);
armor.AddItem(shield);
consumables.AddItem(potion);

// Create nested structure
inventory.AddItem(weapons);    // Container in container
inventory.AddItem(armor);      // Container in container
inventory.AddItem(consumables); // Container in container
inventory.AddItem(gem);        // Direct item in main inventory

// Uniform operations on entire hierarchy
Console.WriteLine(&quot;=== Inventory Display ===&quot;);
inventory.Display(); // Shows entire tree structure recursively

Console.WriteLine($&quot;\nTotal Inventory Value: {inventory.CalculateValue()} gold&quot;);

// Individual operations work the same way
Console.WriteLine(&quot;\n=== Weapons Only ===&quot;);
weapons.Display();
Console.WriteLine($&quot;Weapons Value: {weapons.CalculateValue()} gold&quot;);

// Easy manipulation of complex structures
var treasureChest = new GameContainer(&quot;Treasure Chest&quot;);
treasureChest.AddItem(new SimpleGameItem(&quot;Gold Coins&quot;, 50));
treasureChest.AddItem(new SimpleGameItem(&quot;Diamond Ring&quot;, 300));

// Add entire chest to inventory
inventory.AddItem(treasureChest);

// Party system example
var playerParty = new GameContainer(&quot;Adventure Party&quot;);
var frontLine = new GameContainer(&quot;Front Line&quot;);
var backLine = new GameContainer(&quot;Back Line&quot;);

// Add individual party members
frontLine.AddItem(new SimpleGameItem(&quot;Warrior (Tank)&quot;, 150));
frontLine.AddItem(new SimpleGameItem(&quot;Paladin (Tank)&quot;, 160));
backLine.AddItem(new SimpleGameItem(&quot;Mage (DPS)&quot;, 120));
backLine.AddItem(new SimpleGameItem(&quot;Healer (Support)&quot;, 110));

playerParty.AddItem(frontLine);
playerParty.AddItem(backLine);

// Operations on entire party
Console.WriteLine(&quot;\n=== Party Operations ===&quot;);
playerParty.Display();
Console.WriteLine($&quot;Total Party Strength: {playerParty.CalculateValue()}&quot;);

// Benefits demonstrated:
// - Uniform interface for items and containers
// - Recursive operations on complex structures
// - Easy to add/remove items at any level
// - Flexible hierarchy that can be restructured
// - Same code works for simple items and complex nested structures
</code></pre>

<h2>‚ú® Key Benefits</h2>
<ul>
<li><strong>Uniform Interface</strong>: Same operations for individual objects and compositions</li>
<li><strong>Recursive Structure</strong>: Natural tree-like hierarchies</li>
<li><strong>Flexibility</strong>: Easy to add new component types</li>
<li><strong>Simplified Client Code</strong>: No need to distinguish between leaves and composites</li>
</ul>

<h2>üîß Advanced Composite Features</h2>
<pre><code>
// Safe composite with type checking
public class SafeGameContainer : GameComponent {
    private List&lt;GameComponent&gt; children = new List&lt;GameComponent&gt;();
    private readonly Type allowedType;
    
    public SafeGameContainer(string name, Type allowedType = null) : base(name) {
        this.allowedType = allowedType;
    }
    
    public override void AddItem(GameComponent component) {
        if (allowedType != null &amp;&amp; !allowedType.IsAssignableFrom(component.GetType())) {
            throw new InvalidOperationException($&quot;Only {allowedType.Name} allowed in this container&quot;);
        }
        children.Add(component);
    }
}

// Composite with visitor pattern support
public abstract class GameComponent {
    public abstract void Accept(IGameVisitor visitor);
}

public interface IGameVisitor {
    void Visit(SimpleGameItem item);
    void Visit(GameContainer container);
}

// Iterator support for composite
public class GameContainer : GameComponent, IEnumerable&lt;GameComponent&gt; {
    public IEnumerator&lt;GameComponent&gt; GetEnumerator() {
        return children.GetEnumerator();
    }
    
    // Deep iteration through entire tree
    public IEnumerable&lt;GameComponent&gt; GetAllItems() {
        foreach (var child in children) {
            yield return child;
            
            if (child is GameContainer container) {
                foreach (var subItem in container.GetAllItems()) {
                    yield return subItem;
                }
            }
        }
    }
}

// Usage with LINQ
var allWeapons = inventory.GetAllItems()
    .OfType&lt;SimpleGameItem&gt;()
    .Where(item =&gt; item.Name.Contains(&quot;Sword&quot;))
    .ToList();

// Composite with search capabilities
public class SearchableContainer : GameContainer {
    public GameComponent FindByName(string name) {
        if (this.Name == name) return this;
        
        foreach (var child in children) {
            if (child.Name == name) return child;
            
            if (child is SearchableContainer container) {
                var found = container.FindByName(name);
                if (found != null) return found;
            }
        }
        return null;
    }
    
    public List&lt;GameComponent&gt; FindAll(Predicate&lt;GameComponent&gt; criteria) {
        var results = new List&lt;GameComponent&gt;();
        
        if (criteria(this)) results.Add(this);
        
        foreach (var child in children) {
            if (criteria(child)) results.Add(child);
            
            if (child is SearchableContainer container) {
                results.AddRange(container.FindAll(criteria));
            }
        }
        return results;
    }
}
</code></pre>

<h2>üîó Related Patterns</h2>
<ul>
<li><strong>Decorator</strong>: Both use recursive composition but for different purposes</li>
<li><strong>Visitor</strong>: Often used together for operations on composite structures</li>
<li><strong>Iterator</strong>: Used to traverse composite structures</li>
<li><strong>Chain of Responsibility</strong>: Can be implemented using composite structure</li>
</ul>

<h2>üìä UML Diagrams</h2>

<h3>Generic Pattern Structure</h3>
<div class="image-container"><img src="https://raw.githubusercontent.com/Zed101000/Samenvatting/main/PlayerMMO/Composite/generic_composite.png" alt="Generic Composite UML" style="max-width: 100%; height: auto; border: 1px solid #ddd; border-radius: 8px; margin: 20px 0;"></div>

<h3>PlayerMMO Implementation</h3>
<div class="image-container"><img src="https://raw.githubusercontent.com/Zed101000/Samenvatting/main/PlayerMMO/Composite/composite.png" alt="Composite UML" style="max-width: 100%; height: auto; border: 1px solid #ddd; border-radius: 8px; margin: 20px 0;"></div>

<p>---</p>
<a href="./index.html">‚Üê Back to Main Pattern Summary</a>

    </div>
    
    <div class="document-footer">
        <p><em>Generated from PlayerMMO Design Patterns Documentation</em></p>
        <p>¬© 2025 PlayerMMO Project</p>
    </div>
</body>
</html>
